"use server";

import { ChatRole, WorkspaceRole } from "@prisma/client";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { z } from "zod";

import { appendAuditLog } from "@/lib/audit";
import {
  generateAutomationDraft,
  generateKpiLayoutSuggestion,
  summarizeRecords,
} from "@/lib/assistant/service";
import { db } from "@/lib/db";
import { rethrowIfRedirectError } from "@/lib/redirect-error";
import { AuthError, requireWorkspaceRole } from "@/lib/rbac";
import {
  automationDraftSchema,
  kpiDraftSchema,
  summarizeTableSchema,
} from "@/lib/validators/assistant";

const SUMMARY_SAMPLE_LIMIT = 250;

function buildAssistantUrl(params: Record<string, string | undefined>) {
  const searchParams = new URLSearchParams();

  for (const [key, value] of Object.entries(params)) {
    if (value) {
      searchParams.set(key, value);
    }
  }

  const queryString = searchParams.toString();

  return queryString ? `/assistant?${queryString}` : "/assistant";
}

function getErrorMessage(error: unknown) {
  if (error instanceof AuthError) {
    return error.message;
  }

  if (error instanceof z.ZodError) {
    return error.issues[0]?.message ?? "Invalid input.";
  }

  if (error instanceof Error) {
    return error.message;
  }

  return "Unexpected error.";
}

async function getAssistantThread(workspaceId: string, userId: string) {
  const existing = await db.chatThread.findFirst({
    where: {
      workspaceId,
      title: "Assistant",
    },
  });

  if (existing) {
    return existing;
  }

  return db.chatThread.create({
    data: {
      workspaceId,
      title: "Assistant",
      createdBy: userId,
    },
  });
}

async function saveAssistantExchange(params: {
  workspaceId: string;
  userId: string;
  prompt: string;
  response: string;
  action: string;
}) {
  const thread = await getAssistantThread(params.workspaceId, params.userId);

  await db.chatMessage.createMany({
    data: [
      {
        threadId: thread.id,
        authorUserId: params.userId,
        role: ChatRole.USER,
        content: params.prompt,
      },
      {
        threadId: thread.id,
        role: ChatRole.ASSISTANT,
        content: params.response,
      },
    ],
  });

  await appendAuditLog({
    workspaceId: params.workspaceId,
    actorUserId: params.userId,
    action: params.action,
    entityType: "assistant",
    entityId: thread.id,
    metaJson: {
      prompt: params.prompt,
    },
  });
}

export async function summarizeTableAction(formData: FormData) {
  const parsed = summarizeTableSchema.parse({
    workspaceId: formData.get("workspaceId"),
    tableId: formData.get("tableId"),
    filterText: formData.get("filterText") || undefined,
  });

  try {
    const { user } = await requireWorkspaceRole(parsed.workspaceId, [
      WorkspaceRole.ADMIN,
      WorkspaceRole.EDITOR,
      WorkspaceRole.VIEWER,
    ]);

    const table = await db.table.findFirst({
      where: {
        id: parsed.tableId,
        workspaceId: parsed.workspaceId,
      },
      select: {
        id: true,
        name: true,
      },
    });

    if (!table) {
      throw new Error("Table not found.");
    }

    const normalizedFilter = parsed.filterText?.trim().toLowerCase();
    const where = {
      tableId: table.id,
      ...(normalizedFilter
        ? { searchText: { contains: normalizedFilter } }
        : {}),
    };
    const totalMatchingRecords = await db.record.count({ where });
    const records = await db.record.findMany({
      where,
      orderBy: [{ updatedAt: "desc" }, { id: "desc" }],
      take: SUMMARY_SAMPLE_LIMIT,
      select: {
        dataJson: true,
      },
    });

    const result = await summarizeRecords(records, parsed.filterText, {
      totalMatchingRecords,
    });

    await saveAssistantExchange({
      workspaceId: parsed.workspaceId,
      userId: user.id,
      prompt: `Summarize table ${table.name}${parsed.filterText ? ` (filter: ${parsed.filterText})` : ""}`,
      response: result.content,
      action: "assistant.summary.generated",
    });

    revalidatePath("/assistant");
    redirect(
      buildAssistantUrl({
        workspaceId: parsed.workspaceId,
        success: `Summary generated by ${result.provider}.`,
      }),
    );
  } catch (error) {
    rethrowIfRedirectError(error);
    redirect(
      buildAssistantUrl({
        workspaceId: parsed.workspaceId,
        error: getErrorMessage(error),
      }),
    );
  }
}

export async function generateAutomationDraftAction(formData: FormData) {
  const parsed = automationDraftSchema.parse({
    workspaceId: formData.get("workspaceId"),
    prompt: formData.get("prompt"),
  });

  try {
    const { user } = await requireWorkspaceRole(parsed.workspaceId, [
      WorkspaceRole.ADMIN,
      WorkspaceRole.EDITOR,
      WorkspaceRole.VIEWER,
    ]);

    const result = await generateAutomationDraft(parsed.prompt);

    await saveAssistantExchange({
      workspaceId: parsed.workspaceId,
      userId: user.id,
      prompt: parsed.prompt,
      response: result.content,
      action: "assistant.automation_draft.generated",
    });

    revalidatePath("/assistant");
    redirect(
      buildAssistantUrl({
        workspaceId: parsed.workspaceId,
        success: `Automation draft generated by ${result.provider}.`,
      }),
    );
  } catch (error) {
    rethrowIfRedirectError(error);
    redirect(
      buildAssistantUrl({
        workspaceId: parsed.workspaceId,
        error: getErrorMessage(error),
      }),
    );
  }
}

export async function generateKpiDraftAction(formData: FormData) {
  const parsed = kpiDraftSchema.parse({
    workspaceId: formData.get("workspaceId"),
    objective: formData.get("objective"),
  });

  try {
    const { user } = await requireWorkspaceRole(parsed.workspaceId, [
      WorkspaceRole.ADMIN,
      WorkspaceRole.EDITOR,
      WorkspaceRole.VIEWER,
    ]);

    const result = await generateKpiLayoutSuggestion(parsed.objective);

    await saveAssistantExchange({
      workspaceId: parsed.workspaceId,
      userId: user.id,
      prompt: parsed.objective,
      response: result.content,
      action: "assistant.kpi_layout.generated",
    });

    revalidatePath("/assistant");
    redirect(
      buildAssistantUrl({
        workspaceId: parsed.workspaceId,
        success: `KPI layout suggestion generated by ${result.provider}.`,
      }),
    );
  } catch (error) {
    rethrowIfRedirectError(error);
    redirect(
      buildAssistantUrl({
        workspaceId: parsed.workspaceId,
        error: getErrorMessage(error),
      }),
    );
  }
}
