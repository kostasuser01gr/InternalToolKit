#!/usr/bin/env node

/**
 * Interactive setup helper for integration env vars.
 * Writes to .env.local (gitignored).
 *
 * Usage: pnpm setup:integrations
 */

import { createInterface } from "node:readline";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";

const ENV_FILE = resolve(import.meta.dirname, "..", ".env.local");

const VARS = [
  {
    key: "FEATURE_VIBER_BRIDGE",
    description: "Enable Viber bridge mirror (set to '1' to enable)",
    required: false,
    defaultValue: "0",
  },
  {
    key: "VIBER_CHANNEL_AUTH_TOKEN",
    description:
      "Viber Channel auth token (from Channel info â†’ Developer Tools)",
    required: false,
  },
  {
    key: "VIBER_BOT_TOKEN",
    description: "Viber Bot token (fallback delivery method)",
    required: false,
  },
  {
    key: "VIBER_TARGET_GROUP_ID",
    description: "Viber target group ID (for Bot API fallback)",
    required: false,
  },
  {
    key: "VIBER_WEBHOOK_SECRET",
    description: "Viber webhook secret (for inbound two-way sync)",
    required: false,
  },
  {
    key: "VIBER_MIRRORED_CHANNELS",
    description:
      "Comma-separated internal channel slugs to mirror (default: washers-only)",
    required: false,
    defaultValue: "washers-only",
  },
  {
    key: "CRON_SECRET",
    description: "Secret to protect cron endpoints (any random string)",
    required: true,
  },
];

function readExistingEnv() {
  if (!existsSync(ENV_FILE)) return {};
  const content = readFileSync(ENV_FILE, "utf-8");
  const env = {};
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIdx = trimmed.indexOf("=");
    if (eqIdx < 0) continue;
    const key = trimmed.slice(0, eqIdx).trim();
    let val = trimmed.slice(eqIdx + 1).trim();
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    env[key] = val;
  }
  return env;
}

function writeEnv(env) {
  const lines = ["# Integration env vars â€” auto-generated by setup:integrations", "# DO NOT commit this file", ""];
  for (const [key, val] of Object.entries(env)) {
    lines.push(`${key}="${val}"`);
  }
  lines.push("");
  writeFileSync(ENV_FILE, lines.join("\n"), "utf-8");
}

async function prompt(rl, question) {
  return new Promise((resolve) => {
    rl.question(question, (answer) => resolve(answer.trim()));
  });
}

async function main() {
  console.log("\nðŸ”§ Integration Setup Helper\n");
  console.log("This will configure environment variables for integrations.");
  console.log(`Values will be saved to: ${ENV_FILE}\n`);

  const rl = createInterface({ input: process.stdin, output: process.stdout });
  const existing = readExistingEnv();
  const env = { ...existing };

  for (const v of VARS) {
    const current = existing[v.key];
    const display = current ? ` [current: ${current.slice(0, 4)}${"*".repeat(Math.max(0, current.length - 4))}]` : "";
    const defaultHint = v.defaultValue ? ` (default: ${v.defaultValue})` : "";
    const requiredHint = v.required ? " [required]" : "";

    console.log(`${v.description}${requiredHint}`);
    const answer = await prompt(rl, `  ${v.key}${display}${defaultHint}: `);

    if (answer) {
      env[v.key] = answer;
    } else if (current) {
      env[v.key] = current;
    } else if (v.defaultValue) {
      env[v.key] = v.defaultValue;
    }
    console.log("");
  }

  writeEnv(env);
  rl.close();

  console.log(`âœ… Saved to ${ENV_FILE}`);
  console.log("   Restart your dev server for changes to take effect.\n");
}

main().catch((err) => {
  console.error("Setup failed:", err.message);
  process.exit(1);
});
